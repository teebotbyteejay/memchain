#!/usr/bin/env bash
# memchain — tamper-evident hash chains for agent memory files
# v0.2.0 — 2026-02-23
set -euo pipefail

VERSION="0.3.0"
CHAIN_FILE=".memchain.json"
POLICY_FILE=".memchain-policy"

die() { echo "ERROR: $*" >&2; exit 1; }

# portable sha256
sha256() { sha256sum | cut -d' ' -f1; }

# find files to track based on policy or default (*.md)
find_tracked_files() {
  local dir="$1"
  local policy="$dir/$POLICY_FILE"
  
  if [[ -f "$policy" ]]; then
    # policy file: one glob pattern per line, # comments, empty lines ignored
    while IFS= read -r line; do
      line="${line%%#*}"          # strip comments
      line="${line##*( )}"       # trim leading
      line="${line%%*( )}"       # trim trailing
      [[ -z "$line" ]] && continue
      # expand glob relative to dir
      local found
      found=$(find "$dir" -maxdepth 3 -path "$dir/$line" -print0 2>/dev/null | sort -z | tr '\0' '\n') || true
      [[ -n "$found" ]] && echo "$found"
    done < "$policy"
  else
    # default: all .md files within 2 levels
    find "$dir" -maxdepth 2 -name '*.md' -not -name "$CHAIN_FILE" | sort
  fi
}

cmd_init() {
  local dir="${1:-.}"
  [[ -d "$dir" ]] || die "Directory '$dir' does not exist"
  local chain="$dir/$CHAIN_FILE"
  [[ -f "$chain" ]] && die "Chain already exists at $chain"
  
  cat > "$chain" <<EOF
{
  "version": 2,
  "created": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "entries": []
}
EOF
  echo "✓ Initialized memchain at $chain"
  
  # hint about policy
  if [[ ! -f "$dir/$POLICY_FILE" ]]; then
    echo "  Tip: create $dir/$POLICY_FILE to control which files are tracked"
    echo "  (defaults to all .md files)"
  fi
}

cmd_policy_init() {
  local dir="${1:-.}"
  local policy="$dir/$POLICY_FILE"
  [[ -f "$policy" ]] && die "Policy already exists at $policy"
  
  cat > "$policy" <<'EOF'
# .memchain-policy — which files to track
# One glob pattern per line. Comments (#) and blank lines ignored.
# Patterns are relative to the chain directory.

# Track all markdown files (default behavior)
*.md
memory/*.md

# Examples:
# SOUL.md          # track a specific critical file
# config/*.yaml    # track config files
# *.json           # track JSON files
EOF
  echo "✓ Created policy at $policy"
}

cmd_record() {
  local dir="${1:-.}"
  local chain="$dir/$CHAIN_FILE"
  [[ -f "$chain" ]] || die "No chain found. Run: memchain init $dir"

  # collect hashes of tracked files
  local file_hashes=""
  local combined=""
  local count=0
  
  while IFS= read -r f; do
    [[ -z "$f" ]] && continue
    [[ "$f" == *"$CHAIN_FILE"* ]] && continue
    [[ "$f" == *"$POLICY_FILE"* ]] && continue
    [[ -f "$f" ]] || continue
    local rel="${f#$dir/}"
    local h
    h=$(sha256 < "$f")
    if [[ $count -gt 0 ]]; then
      file_hashes="$file_hashes,"
    fi
    file_hashes="$file_hashes
      \"$rel\": \"sha256:$h\""
    combined="${combined}${rel}:${h}\n"
    count=$((count + 1))
  done < <(find_tracked_files "$dir")

  [[ $count -eq 0 ]] && die "No tracked files found in $dir"

  # content hash = hash of all file hashes combined
  local content_hash
  content_hash=$(printf "$combined" | sha256)

  # get previous entry hash
  local prev_hash
  prev_hash=$(python3 -c "
import json, sys
with open('$chain') as f:
    data = json.load(f)
entries = data.get('entries', [])
if entries:
    print(entries[-1]['entry_hash'])
else:
    print('null')
")

  local seq
  seq=$(python3 -c "
import json
with open('$chain') as f:
    data = json.load(f)
print(len(data.get('entries', [])))
")

  local ts
  ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)

  # entry hash = hash of (seq + timestamp + content_hash + prev_hash)
  local entry_hash
  entry_hash=$(printf "%s|%s|%s|%s" "$seq" "$ts" "sha256:$content_hash" "$prev_hash" | sha256)

  # append entry using python for safe JSON manipulation
  python3 -c "
import json
with open('$chain') as f:
    data = json.load(f)

entry = {
    'seq': $seq,
    'timestamp': '$ts',
    'files_count': $count,
    'files': {${file_hashes}
    },
    'content_hash': 'sha256:$content_hash',
    'prev_hash': '$prev_hash' if '$prev_hash' != 'null' else None,
    'entry_hash': 'sha256:$entry_hash'
}

data['entries'].append(entry)
data['version'] = 2

with open('$chain', 'w') as f:
    json.dump(data, f, indent=2)
"
  echo "✓ Recorded entry #$seq — $count files, hash: sha256:${entry_hash:0:16}..."
}

cmd_verify() {
  local dir="${1:-.}"
  local strict=0
  
  # parse flags
  for arg in "$@"; do
    case "$arg" in
      --strict) strict=1 ;;
    esac
  done
  
  # first non-flag arg is dir
  for arg in "$@"; do
    [[ "$arg" == --* ]] && continue
    dir="$arg"
    break
  done
  
  local chain="$dir/$CHAIN_FILE"
  [[ -f "$chain" ]] || die "No chain found at $chain"

  python3 -c "
import json, hashlib, sys, os

strict = $strict

def sha256(data):
    return hashlib.sha256(data.encode()).hexdigest()

with open('$chain') as f:
    data = json.load(f)

entries = data.get('entries', [])
if not entries:
    print('⚠ Chain is empty — nothing to verify')
    sys.exit(0)

errors = 0
drift_files = 0
for i, entry in enumerate(entries):
    # verify chain linkage
    expected_prev = entries[i-1]['entry_hash'] if i > 0 else None
    if entry['prev_hash'] != expected_prev:
        print(f'✗ Entry #{entry[\"seq\"]}: broken chain link')
        print(f'  expected prev: {expected_prev}')
        print(f'  got:           {entry[\"prev_hash\"]}')
        errors += 1
        continue

    # verify entry hash
    prev_str = entry['prev_hash'] if entry['prev_hash'] else 'null'
    recomputed = sha256(f'{entry[\"seq\"]}|{entry[\"timestamp\"]}|{entry[\"content_hash\"]}|{prev_str}')
    if entry['entry_hash'] != f'sha256:{recomputed}':
        print(f'✗ Entry #{entry[\"seq\"]}: entry hash mismatch')
        errors += 1
        continue

    # verify current file hashes (only for latest entry)
    is_latest = (i == len(entries) - 1)
    file_changes = 0
    changed_names = []
    for rel_path, stored_hash in entry['files'].items():
        full_path = os.path.join('$dir', rel_path)
        if os.path.exists(full_path):
            with open(full_path, 'rb') as ff:
                current = 'sha256:' + hashlib.sha256(ff.read()).hexdigest()
            if current != stored_hash:
                file_changes += 1
                if is_latest:
                    changed_names.append(rel_path)
        elif is_latest:
            file_changes += 1
            changed_names.append(f'{rel_path} (missing)')

    if is_latest and file_changes > 0:
        drift_files = file_changes
        status = f'⚡ {file_changes} file(s) changed since last record'
        print(f'✓ Entry #{entry[\"seq\"]} [{entry[\"timestamp\"]}] — chain valid, {status}')
        if strict:
            for cn in changed_names:
                print(f'  ⚡ {cn}')
    else:
        print(f'✓ Entry #{entry[\"seq\"]} [{entry[\"timestamp\"]}] — chain valid')

if errors:
    print(f'\n✗ CHAIN BROKEN — {errors} error(s) found')
    sys.exit(1)
elif strict and drift_files > 0:
    print(f'\n⚠ DRIFT DETECTED — {drift_files} file(s) modified since last record')
    print('  Run \"memchain record\" to accept current state, or investigate changes.')
    sys.exit(2)
else:
    print(f'\n✓ Chain intact — {len(entries)} entries verified')
    sys.exit(0)
"
}

cmd_log() {
  local dir="${1:-.}"
  local chain="$dir/$CHAIN_FILE"
  [[ -f "$chain" ]] || die "No chain found at $chain"

  python3 -c "
import json
with open('$chain') as f:
    data = json.load(f)

entries = data.get('entries', [])
if not entries:
    print('(empty chain)')
else:
    for e in entries:
        h = e['entry_hash'][:23] + '...'
        print(f'#{e[\"seq\"]:03d}  {e[\"timestamp\"]}  {e[\"files_count\"]} files  {h}')
"
}

cmd_status() {
  local dir="${1:-.}"
  local chain="$dir/$CHAIN_FILE"
  [[ -f "$chain" ]] || die "No chain found at $chain"
  
  python3 -c "
import json, hashlib, os

with open('$chain') as f:
    data = json.load(f)

entries = data.get('entries', [])
policy_path = '$dir/$POLICY_FILE'
has_policy = os.path.exists(policy_path)

print(f'memchain v$VERSION')
print(f'Chain: $chain ({len(entries)} entries)')
print(f'Policy: {policy_path if has_policy else \"(default: *.md)\"}')

if entries:
    latest = entries[-1]
    print(f'Latest: #{latest[\"seq\"]} at {latest[\"timestamp\"]} ({latest[\"files_count\"]} files)')
    
    changed = 0
    for rel_path, stored_hash in latest['files'].items():
        full_path = os.path.join('$dir', rel_path)
        if os.path.exists(full_path):
            with open(full_path, 'rb') as ff:
                current = 'sha256:' + hashlib.sha256(ff.read()).hexdigest()
            if current != stored_hash:
                changed += 1
                print(f'  ⚡ {rel_path} (modified)')
        else:
            changed += 1
            print(f'  ✗ {rel_path} (missing)')
    
    if changed == 0:
        print('  All files match last record ✓')
"
}

cmd_help() {
  cat <<EOF
memchain v$VERSION — tamper-evident hash chains for agent memory

Usage:
  memchain init [dir]            Initialize a new chain
  memchain record [dir]          Record current state of tracked files
  memchain verify [dir]          Verify chain integrity
  memchain verify --strict [dir] Verify + fail on file drift (exit 2)
  memchain status [dir]          Show chain status and file drift
  memchain log [dir]             Show chain history
  memchain policy-init [dir]     Create a .memchain-policy template
  memchain anchor [dir]          Push chain head to GitHub Gist (external witness)
  memchain anchor-verify [dir]   Verify local chain against remote anchor
  memchain help                  Show this help

Files:
  .memchain.json    Chain data (append-only)
  .memchain-policy  File tracking patterns (optional)
  .memchain-anchor  Gist ID for external anchoring

EOF
}

cmd_anchor() {
  local dir="${1:-.}"
  local chain="$dir/$CHAIN_FILE"
  [[ -f "$chain" ]] || die "No chain found at $chain"
  
  command -v gh >/dev/null 2>&1 || die "GitHub CLI (gh) required for anchoring. Install: https://cli.github.com"
  
  # Get latest entry
  local anchor_data
  anchor_data=$(python3 -c "
import json, os
with open('$chain') as f:
    data = json.load(f)
entries = data.get('entries', [])
if not entries:
    print('EMPTY')
else:
    e = entries[-1]
    print(json.dumps({
        'chain': os.path.abspath('$chain'),
        'seq': e['seq'],
        'timestamp': e['timestamp'],
        'entry_hash': e['entry_hash'],
        'content_hash': e['content_hash'],
        'files_count': e['files_count'],
        'anchored_at': '$(date -u +%Y-%m-%dT%H:%M:%SZ)',
        'total_entries': len(entries)
    }, indent=2))
")
  
  [[ "$anchor_data" == "EMPTY" ]] && die "Chain is empty — nothing to anchor"
  
  local anchor_file="$dir/.memchain-anchor"
  local gist_id=""
  
  # Check for existing gist ID
  if [[ -f "$anchor_file" ]]; then
    gist_id=$(cat "$anchor_file")
  fi
  
  # Create temp file with anchor content
  local tmpfile
  tmpfile=$(mktemp /tmp/memchain-anchor-XXXXXX.json)
  echo "$anchor_data" > "$tmpfile"
  
  if [[ -n "$gist_id" ]]; then
    # Update existing gist
    gh gist edit "$gist_id" "$tmpfile" 2>/dev/null || {
      # Gist might be deleted, create new
      gist_id=""
    }
  fi
  
  if [[ -z "$gist_id" ]]; then
    # Create new gist
    local gist_url
    gist_url=$(gh gist create "$tmpfile" --desc "memchain anchor — tamper-evident chain head" --public 2>&1 | grep "gist.github.com")
    gist_id=$(echo "$gist_url" | grep -oP '[a-f0-9]{20,}' || echo "$gist_url" | awk -F/ '{print $NF}')
    echo "$gist_id" > "$anchor_file"
  fi
  
  rm -f "$tmpfile"
  
  local seq
  seq=$(echo "$anchor_data" | python3 -c "import json,sys; print(json.load(sys.stdin)['seq'])")
  
  echo "✓ Anchored entry #$seq to GitHub Gist"
  echo "  Gist: https://gist.github.com/$gist_id"
  echo "  Verify: compare entry_hash in gist vs local chain"
  
  if [[ ! -f "$anchor_file.bak" ]]; then
    echo "  Tip: the gist URL is stored in $anchor_file"
  fi
}

cmd_anchor_verify() {
  local dir="${1:-.}"
  local chain="$dir/$CHAIN_FILE"
  local anchor_file="$dir/.memchain-anchor"
  
  [[ -f "$chain" ]] || die "No chain found at $chain"
  [[ -f "$anchor_file" ]] || die "No anchor found. Run: memchain anchor $dir"
  
  command -v gh >/dev/null 2>&1 || die "GitHub CLI (gh) required"
  
  local gist_id
  gist_id=$(cat "$anchor_file")
  
  # Fetch gist content (--raw may include description header, extract JSON)
  local remote_raw
  remote_raw=$(gh gist view "$gist_id" --raw 2>/dev/null) || die "Could not fetch gist $gist_id"
  
  local remote_data
  remote_data=$(echo "$remote_raw" | python3 -c "
import sys, json
text = sys.stdin.read()
# Find the JSON object in the output
start = text.index('{')
end = text.rindex('}') + 1
print(text[start:end])
")
  
  local remote_hash
  remote_hash=$(echo "$remote_data" | python3 -c "import json,sys; print(json.load(sys.stdin)['entry_hash'])")
  
  local remote_seq
  remote_seq=$(echo "$remote_data" | python3 -c "import json,sys; print(json.load(sys.stdin)['seq'])")
  
  # Get local latest
  local local_hash
  local_hash=$(python3 -c "
import json
with open('$chain') as f:
    data = json.load(f)
entries = data.get('entries', [])
if entries:
    print(entries[-1]['entry_hash'])
else:
    print('EMPTY')
")
  
  local local_seq
  local_seq=$(python3 -c "
import json
with open('$chain') as f:
    data = json.load(f)
print(len(data.get('entries', [])) - 1)
")
  
  echo "Remote anchor: entry #$remote_seq — $remote_hash"
  echo "Local latest:  entry #$local_seq — $local_hash"
  
  if [[ "$remote_hash" == "$local_hash" ]]; then
    echo "✓ Anchor matches local chain head"
    return 0
  elif [[ "$local_seq" -gt "$remote_seq" ]]; then
    echo "⚡ Local chain is ahead of anchor (run 'memchain anchor' to update)"
    return 0
  else
    echo "✗ MISMATCH — local chain does not contain the anchored state"
    echo "  This could indicate tampering or chain rollback"
    return 1
  fi
}

case "${1:-help}" in
  init)            cmd_init "${2:-}" ;;
  record)          cmd_record "${2:-}" ;;
  verify)          shift; cmd_verify "$@" ;;
  status)          cmd_status "${2:-}" ;;
  log)             cmd_log "${2:-}" ;;
  policy-init)     cmd_policy_init "${2:-}" ;;
  anchor)          cmd_anchor "${2:-}" ;;
  anchor-verify)   cmd_anchor_verify "${2:-}" ;;
  help|*)          cmd_help ;;
esac
